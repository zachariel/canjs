<!DOCTYPE html>
<!--####################################################################
	THIS IS A GENERATED FILE -- ANY CHANGES MADE WILL BE OVERWRITTEN

	INSTEAD CHANGE:
	source: docs/can-guides/experiment/technology/technology.md
	@page guides/technology-overview
######################################################################## -->
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>CanJS - Technology Overview</title>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	
		<link rel="stylesheet" type="text/css" href="../static/bundles/bit-docs-site/static.css">
		<link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" href="/docs/images/canjs_favicon.ico">
		<link rel="apple-touch-icon" sizes="57x57" href="../../docs/images/canjs_favicon_57x57.png">
		<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../docs/images/canjs_favicon_57x57.png">
		<link rel="apple-touch-icon" sizes="72x72" href="../../docs/images/canjs_favicon_72x72.png">
		<link rel="apple-touch-icon" sizes="114x114" href="../../docs/images/canjs_favicon_114x114.png">
		<link rel="apple-touch-icon" sizes="120x120" href="../../docs/images/canjs_favicon_128x128.png">
		<link rel="apple-touch-icon" sizes="144x144" href="../../docs/images/canjs_favicon_144x144.png">
		<link rel="apple-touch-icon" sizes="152x152" href="../../docs/images/canjs_favicon_152x152.png">
		<meta content="yes" name="apple-mobile-web-app-capable">
	  	<meta name="apple-mobile-web-app-status-bar-style" content="white-translucent">
	
	
		<script>
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
				(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
				m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

			ga('create', 'UA-2302003-11', 'auto');
			ga('send', 'pageview');
		</script>
	
</head>
	<body>
		<input type="checkbox" id="nav-trigger" class="nav-trigger"/>
		<label for="nav-trigger">Menu</label>
	  	<div id="everything">
  <div id="left" class="column">
    <div class="top-left">
      
          <div class="brand">
	<div class="logo">
		<a href="../../index.html" alt="CanJS"></a>
		<div class="dropdown project-dropdown">
			<a href="https://donejs.com/">DoneJS</a>
			<a href="https://stealjs.com/">StealJS</a>
			<a href="https://jquerypp.com/">jQuery++</a>
			<a href="https://funcunit.com/">FuncUnit</a>
			<a href="https://documentjs.com/">DocumentJS</a>
		</div>
	</div>
	<div class="version">
		<div class="version-number">
			4.0.1
		</div>
		<div class="dropdown version-dropdown">
			
				<a href="https://v3.canjs.com">3.12.1</a>
			
				<a href="https://v2.canjs.com">2.3.33</a>
			
		</div>
	</div>
</div>
<div class="search-bar">
	<div class="search-wrap" style="display:none;">
		<span class="search-icon"></span>
		<input
			type="text"
			size="6"
			class="search"
			placeholder="Search"
			autocomplete="off"
			autocorrect="off"
			autocapitalize="none"
			spellcheck="false"/>
			<span class="search-icon-cancel"></span>
	</div>
</div>


      
    </div>
    <div class="bottom">
      <div class="nav-menu">
        <div class="social-side-container">
          <ul class="social-side">
  <li>
    <a class="header-mobile github" href="https://github.com/canjs/canjs" target="_blank"><img class="social-icon-small" src="../../docs/images/github.png">Github</a>
  </li>
  <li>
    <a class="header-mobile twitter" href="https://twitter.com/canjs" target="_blank"><img class="social-icon-small" src="../../docs/images/twitter.png">Twitter</a>
  </li>
</ul>
<ul class="social-side">
  <li>
    <a class="header-mobile" href="https://gitter.im/canjs/canjs" target="_blank">Chat</a>
  </li>
  <li>
    <a class="header-mobile" href="http://forums.donejs.com/c/canjs" target="_blank">Forum</a>
  </li>
</ul>

        </div>
        
            
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../about.html"
							title="Learn about CanJS’s mission, technical highlights, who uses CanJS, and our future roadmap.">
							About
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						parent
           						expanded">
						<a class="page"
							href="../guides.html"
							title="Welcome to CanJS! These guides are here to help you develop and improve your relationship with CanJS. After all, picking a JavaScript framework is a commitment.  We want CanJS to be the framework you marry.  This page helps you know how to advance through the different stages of this relationship:">
							Guides
						</a>
						
	<ul>
		
			
				
					<li>
						<span>experiment</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="chat.html"
							title="This guide will walk you through building a real-time chat application with CanJS’s Core libraries.  It takes about 30 minutes to complete.">
							Chat Guide
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="todomvc.html"
							title="This guide will walk you through building a slightly modified version of TodoMVC with CanJS’s Core libraries and can-fixture. It takes about 1 hour to complete.">
							TodoMVC Guide
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="atm.html"
							title="This guide will walk you through building and testing an Automated Teller Machine (ATM) application with CanJS’s
Core libraries.  You’ll learn how to do test driven development (TDD)
and manage complex state.  It takes about 2 hours to complete.">
							ATM Guide
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>getting started</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="setup.html"
							title="Get started with CanJS by installing it with npm, using a JS&amp;nbsp;Bin, or just adding it to an HTML page with a &lt;script&gt; tag.">
							Setting up CanJS
						</a>
						

					</li>
				
			
		
			
				
					<li class="current
           						
           						expanded">
						<a class="page"
							href="technology-overview.html"
							title="Learn the basics of the core parts of CanJS&#x27;s technology.">
							Technology Overview
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="api.html"
							title="This page walks through how to use and understand CanJS’s API documentation.">
							Reading the Docs (API Guide)
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li class="
           						parent
           						">
						<a class="page"
							href="recipes.html"
							title="A listing of small examples that are useful for learning CanJS.">
							recipes
						</a>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="recipes/canvas-clock.html"
							title="This guide walks you through building a canvas clock.">
							Canvas Clock (Simple)
						</a>
						

					</li>
				
			
		
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="recipes/credit-card-simple.html"
							title="This guide walks through building a very simple credit card payment form.  It uses Stripe.js v2 API to create a token
which can be used to create a charge.  It also performs
simple validation on the payment form values.">
							Credit Card Guide (Simple)
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="recipes/cta-bus-map.html"
							title="This guide walks you through showing Chicago Transit Authority (CTA) bus locations on a Google Map.">
							CTA Bus Map (Medium)
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="recipes/file-navigator-advanced.html"
							title="This guide walks you through building a file navigation widget.  It takes about 45 minutes to complete.  It was written with
CanJS 3.10. Check out the file-navigator-simple
for an easier example that produces similar functionality.">
							File Navigator Guide (Advanced)
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="recipes/file-navigator-simple.html"
							title="This guide walks you through building a simple file navigation widget.  It takes about 25 minutes to complete.  It was written with
CanJS 3.10. Check out the file-navigator-advanced
for an example that makes AJAX requests for its data and uses can-component.">
							File Navigator Guide (Simple)
						</a>
						

					</li>
				
			
		
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="recipes/signup-simple.html"
							title="This guide walks through building simple signup, login forms and a logout button.">
							Signup and Login (Simple)
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="recipes/text-editor.html"
							title="This guide walks you through building a basic rich text editor.">
							Text Editor (Medium)
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="recipes/todomvc-with-steal.html"
							title="This guide walks through building TodoMVC with StealJS.">
							TodoMVC with StealJS
						</a>
						

					</li>
				
			
		
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="recipes/weather-report-simple.html"
							title="This guide walks you through building a simple weather report widget.  It takes about 25 minutes to complete.  It was written with
CanJS 3.5.">
							Weather Report Guide (Simple)
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>topics</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="debugging.html"
							title="Learn how to debug CanJS applications.">
							Debugging Guide
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="forms.html"
							title="Learn how to create amazing &lt;form&gt;s with CanJS. This guide gives an overview of binding to form element attributes and events, then describes the ins and outs of common elements, and finally discusses a few more advanced topics. We recommend reading the Bindings overview section first before jumping to the topic that interests you &amp;mdash; or start at the top to become an expert on it all.">
							Forms Guide
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>upgrade</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../migrate-3.html"
							title="This guide walks you through the step-by-step process to upgrade a 2.x app to CanJS 3.">
							Migrating to CanJS 3
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../migrate-4.html"
							title="This guide walks you through the step-by-step process to upgrade a 3.x app to CanJS 4.">
							Migrating to CanJS 4
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="upgrade/using-codemods.html"
							title="Learn how to migrate your app to CanJS 3 using can-migrate.">
							Using Codemods
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../api.html"
							title="Welcome to the CanJS API documentation! Learn about all the packages that make-up CanJS and how they work together to help you build amazing applications.">
							API Docs
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../community.html"
							title="Get involved with one of the most inviting communities on the internet!">
							Community
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="contribute.html"
							title="Learn how to contribute to CanJS!">
							Contributing
						</a>
						

					</li>
				
			
		
	</ul>


        
      </div>
      <div class="search-results-container">
	<div class="search-results-wrap"></div>
</div>

    </div>
  </div>
  <div id="right" class="column">
    <div class="top-right">
      <div class="top-right-top">
	<ul class="top-right-bitovi">
	  	<li class="dropdown">
	    	<a href="https://www.bitovi.com" class="bitovi icon-bits">Bitovi</a>
	    	<ul class="dropdown-menu">
	      		<li><a href="https://www.bitovi.com/">Bitovi.com</a></li>
	      		<li><a href="https://www.bitovi.com/blog">Blog</a></li>
	      		<li><a href="https://www.bitovi.com/design">Design</a></li>
	      		<li><a href="https://www.bitovi.com/development">Development</a></li>
	      		<li><a href="https://www.bitovi.com/training">Training</a></li>
	      		<li><a href="https://www.bitovi.com/open-source">Open Source</a></li>
	      		<li><a href="https://www.bitovi.com/about">About</a></li>
	      		<li><a href="https://www.bitovi.com/contact">Contact Us</a></li>
	    	</ul>
	  	</li>
	</ul>
	<div class="brand">
		<div class="logo">
			<a href="../../index.html" alt="CanJS"></a>
		</div>
	</div>
	<ul class="top-right-links">
  <li>
    <a href="https://gitter.im/canjs/canjs">Chat</a>
  </li>
  <li>
    <a href="http://forums.donejs.com/c/canjs">Forum</a>
  </li>
  <li>
    <a class="github-button nav-social" href="https://github.com/canjs/canjs" data-count-href="/canjs/canjs/stargazers" data-show-count="true">Star</a>
  </li>
  <li>
    <a href="https://twitter.com/canjs" class="twitter-follow-button nav-social" data-show-count="true" data-show-screen-name="false">Follow @canjs</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
  </li>
</ul>
</div>
<div class="breadcrumb">
	
		<li><a href="../../index.html">CanJS</a></li>
		<li> / </li>
	
		<li><a href="../guides.html">Guides</a></li>
		<li> / </li>
	
	
	<li><a href="technology-overview.html">Technology Overview</a></li>
	
	<li class="breadcrumb-dropdown-separator"> / </li>
	<li class="breadcrumb-dropdown">
		<a> On this page</a>
		<ul class="on-this-page"></ul>
	</li>
	<div class="nav-toggle" title="Back to top"></div>
</div>


    </div>
    <div class="bottom">
      <article>
  <section class="title">
	<div class="page-type">
		<h1>Technology Overview</h1>
			<ul class="title-social">
				
				
				<li>
					<a class="button-link" href="//github.com/canjs/canjs/edit/master/docs/can-guides/experiment/technology/technology.md">Edit on GitHub</a>
				</li>
				
			</ul>
	</div>
	<div class="clear-both"></div>
	
  
	<section class="description">
    <p>Learn the basics of the core parts of CanJS's technology.</p>

</section>

  
	
</section>
<section class="on-this-page-table">
</section>











  
    <section class="body">
    <h2>Overview</h2>
<p>CanJS, at its most simplified, consists of key-value <strong>Observables</strong>
connected to different web browser APIs through various connecting
libraries.</p>
<p><img src="../../docs/can-guides/experiment/technology/overview.svg"
alt="Observables are the center hub.  They are connected to the DOM by the view layer, the service layer by the data modeling layer, and the window location by the routing layer"
class='bit-docs-screenshot' width='600px'/></p>
<p>The general idea is that you create observable objects that encapsulate
the logic and state of your application and connect those observable
objects to:</p>
<ul>
<li>The Document Object Model (DOM) to update your page automatically.</li>
<li>The route to support the forward and back button.</li>
<li>Your service layer to make receiving, creating, updating, and deleting server data easier.</li>
</ul>
<p>Instead of worrying about calling the various browser APIs, CanJS abstracts this
away, so you can focus on the logic of your application. The logic of your
application is contained within observables.</p>
<p>The rest of this guide walks you through:</p>
<ul>
<li>Defining your own <a href="#Key_ValueObservables">key-value observable</a> types and
adding logic to them.</li>
<li>Connecting those <a href="#ObservablesandHTMLElements">observables to DOM elements</a> using:
<ul>
<li>stache templates like <code>&lt;span&gt;{{count}}&lt;/span&gt;</code>,</li>
<li>bindings like <code>&lt;input value:bind='count'&gt;</code>, and</li>
<li>components that create custom elements like <code>&lt;my-counter/&gt;</code>.</li>
</ul></li>
<li>Connecting <a href="#Observablesandthebrowser_slocation">observables to the browser's location</a> and
building an example app that routes between different pages, including a login screen.</li>
</ul>
<h2>Key-Value Observables</h2>
<p>The <a href="../can-define/map/map.html" title="Create observable objects.">DefineMap</a> and
<a href="../can-define/list/list.html" title="Create observable lists.">DefineList</a> <strong>Observables</strong> define the logic and state
in your application. For example, if we wanted to model
a simple counter, we can use <a href="../can-define/map/map.html" title="Create observable objects.">DefineMap</a> as follows:</p>
<pre><code class="language-js">import DefineMap from &quot;can-define/map/map&quot;;
var Counter = DefineMap.extend({
    count: {default: 0},
    increment() {
        this.count++;
    }
});
</code></pre>
<p>We can create instances of <code>Counter</code>, call its methods, and
inspect its state like so:</p>
<pre><code class="language-js">var myCounter = new Counter();
myCounter.count //-&gt; 0
myCounter.increment()
myCounter.count //-&gt; 1
</code></pre>
<p><code>myCounter</code> is an instance of <code>Counter</code>. <code>myCounter.count</code> is what we call the <em>state</em> of the <code>myCounter</code> instance.  <code>myCounter.increment</code> is part of the <em>logic</em> that controls the
state of <code>myCounter</code>.</p>
<blockquote>
<p><strong>NOTE:</strong> CanJS application logic is coded within instances of <code>DefineMap</code> and <code>DefineList</code>.
You often don’t need the DOM for unit testing!</p>
</blockquote>
<p><a href="../can-define/map/map.html" title="Create observable objects.">DefineMap</a> and <a href="../can-define/list/list.html" title="Create observable lists.">DefineList</a> have a wide variety of features (and shorthands)
for defining property behavior. In the previous example, <code>count: {default: 0}</code> defined the <code>count</code> property to
have an initial value of <code>0</code>. The <code>{default: 0}</code> object is a <a href="../can-define.types.propDefinition.html" title="Defines the type, initial value, and get, set, and serialize behavior for an
observable property.  These behaviors can be specified with as an Object, String,
Constructor function, Array, a getter expression, or setter expression.">PropDefinition</a>.</p>
<p>The following example uses the <a href="../can-define.types.default.html" title="Returns the default value for instances of the defined type.  The default value is defined on demand, when the property
is read for the first time.">default</a> and <a href="../can-define.types.get.html" title="Specify what happens when a certain property is read on a map. get functions
work like a can-compute and automatically update themselves when a dependent
observable value is changed.">get</a> property
definition behaviors to define a <code>TodosApp</code> constructor function's <code>todos</code> and <code>completeCount</code>
property behavior:</p>
<pre><code class="language-js">var TodosApp = DefineMap.extend({
    todos: {
        // todos defaults to a DefineList of todo data.
        default: () =&gt; new DefineList([
            {complete: true, name: &quot;Do the dishes.&quot;},
            {complete: true, name: &quot;Wash the car.&quot;},
            {complete: false, name: &quot;Learn CanJS.&quot;}
        ])
    },
    // completedCount is the number of completed todos in the `todos`
    // property.
    completeCount: {
        get() {
            return this.todos.filter({complete: true}).length
        }
    }
});
</code></pre>
<p>Instances of <code>TodosApp</code> will have default <code>todos</code> value and a <code>completeCount</code>
that dynamically changes when <code>todos</code> changes:</p>
<pre><code class="language-js">var todosApp = new TodosApp();
todosApp.todos //-&gt; DefineList[{complete: true, name: &quot;Do the dishes.&quot;}, ...]

todosApp.completeCount //-&gt; 2

todosApp.todos[2].complete = true;

todosApp.completeCount //-&gt; 3
</code></pre>
<h2>Observables and HTML Elements</h2>
<p>CanJS's pattern is that you define application logic in one or
more observables, then you connect these observables to
various browser APIs. The page's HTML (DOM) is the
most common browser API people need to connect to. <a href="../can-stache.html" title="Live binding Mustache and Handlebars-compatible templates.">can-stache</a>, <a href="../can-stache-bindings.html" title="Provides template event, one-way bindings, and two-way bindings.">can-stache-bindings</a>
and <a href="../can-component.html" title="Create a custom element that can be used to manage widgets or application logic.">can-component</a> are used to connect the DOM
to <strong>observables</strong> like <code>myCounter</code>. We can create HTML that:</p>
<ul>
<li>Calls methods on observables using <a href="../can-stache-bindings.html" title="Provides template event, one-way bindings, and two-way bindings.">can-stache-bindings</a>.</li>
<li>Updates the page when the state of an observable changes using <a href="../can-stache.html" title="Live binding Mustache and Handlebars-compatible templates.">can-stache</a>.</li>
</ul>
<p>The following example increments the <em>Count</em> when the <button>+1</button> is clicked:</p>
<div class='demo_wrapper' data-demo-src='demos/technology-overview/observable-dom.html'></div>
<blockquote>
<p><strong>NOTE:</strong> Click the <strong>JS</strong> tab to see the code.</p>
</blockquote>
<p>The demo uses a <a href="../can-stache.html" title="Live binding Mustache and Handlebars-compatible templates.">can-stache</a> view:</p>
<pre><code class="language-js">var view = stache(`
  &lt;button on:click='increment()'&gt;+1&lt;/button&gt;
  Count: &lt;span&gt;{{count}}&lt;/span&gt;
`);
</code></pre>
<p>The <em>view</em>:</p>
<ul>
<li>Updates a <code>&lt;span/&gt;</code> when the state of <code>myCounter</code> changes <em>using</em> <code>{{count}}</code>.</li>
<li>Creates a <button>+1</button> button that calls methods on <code>myCounter</code> when DOM events happen <em>using</em> <code>on:click='increment()'</code>.</li>
</ul>
<h3>Stache templates and bindings</h3>
<p><a href="../can-stache.html" title="Live binding Mustache and Handlebars-compatible templates.">can-stache</a> is used to create HTML that updates automatically when observable
state changes. It uses magic tags to read values and perform simple logic. The following
are the most commonly used tags:</p>
<ul>
<li><a href="../can-stache.tags.escaped.html" title="Insert the value of the expression into the output of the template.">{{expression}}</a> - Inserts the result of <code>expression</code> in the page.
<pre><code class="language-html">Count: &lt;span&gt;{{count}}&lt;/span&gt;
</code></pre></li>
<li><a href="../can-stache.helpers.if.html" title="can-stache.helpers.if">{{#if(expression)}}</a> - Render the <em>block</em> content if the expression evaluates
to a <em>truthy</em> value; otherwise, render the <em>inverse</em> content.
<pre><code class="language-html">{{#if(count)}} Count not 0 {{else}} Count is 0 {{/if}}
</code></pre></li>
<li><a href="../can-stache.helpers.is.html" title="Render something if two values are equal.">{{#is(expressions)}}</a> - Render the <em>block</em> content if all comma seperated expressions
evaluate to the same value; otherwise, render the <em>inverse</em> content.
<pre><code class="language-html">{{#is(count, 1)}} Count is 1 {{else}} Count is not 1 {{/if}}
</code></pre></li>
<li><a href="../can-stache.helpers.each.html" title="">{{#each(expression)}}</a> - Render the <em>block</em> content for each item in the list the expression evaluates to.
<pre><code class="language-html">{{#each(items)}} {{name}} {{/each}}
</code></pre></li>
</ul>
<p><a href="../can-stache-bindings.html" title="Provides template event, one-way bindings, and two-way bindings.">can-stache-bindings</a> is used pass values between the DOM and observables and call methods on
observables. Use it to:</p>
<ul>
<li>Call methods on observables when DOM events happen. The following uses
<a href="../can-stache-bindings.event.html" title="Respond to events on elements or component ViewModels.">on:event</a> to call <code>doSomething</code> with the <code>&lt;input&gt;</code>'s value on a <code>keypress</code> event:
<pre><code class="language-html">&lt;input on:keypress=&quot;doSomething(scope.element.value)&quot;/&gt;
</code></pre></li>
<li>Update observables with element attribute and property values.  The following uses <a href="../can-stache-bindings.toParent.html" title="One-way bind a value from the viewModel or element to the parent scope.">toParent:to</a>
to send the <code>&lt;input&gt;</code>'s <em>value to</em> an observable's <code>count</code> property.
<pre><code class="language-html">&lt;input value:to=&quot;count&quot;/&gt;
</code></pre></li>
<li>Update element attribute and property values with observable values.  The following uses <a href="../can-stache-bindings.toChild.html" title="One-way bind a value in the parent scope to the ViewModel or element.">toChild:from</a>
to update the <code>&lt;input&gt;</code>'s <em>value from</em>  an observable's <code>count</code> property.
<pre><code class="language-html">&lt;input value:from=&quot;count&quot;/&gt;
</code></pre></li>
<li>Cross bind element attribute and property values with observable values.  The following uses
<a href="../can-stache-bindings.twoWay.html" title="Two-way bind a value in the viewModel or the element to the parent scope.">twoWay:bind</a> to update the <code>&lt;input&gt;</code>'s <em>value</em> from  an observable's <code>count</code> property
and vice versa:
<pre><code class="language-html">&lt;input value:bind=&quot;count&quot;/&gt;
</code></pre></li>
</ul>
<p>The following demo:</p>
<ul>
<li>Loops through a list of todos with <a href="../can-stache.helpers.each.html" title="">{{#each(expression)}}</a> - <code>{{#each( todos )}} ... {{/each}}</code>.</li>
<li>Write out if all todos are complete with <a href="../can-stache.helpers.is.html" title="Render something if two values are equal.">{{#is(expressions)}}</a> - <code>{{#is( completeCount, todos.length )}}</code>.</li>
<li>Update the <code>complete</code> state of a todo when a <em>checkbox</em> is checked and vice-versa with <a href="../can-stache-bindings.twoWay.html" title="Two-way bind a value in the viewModel or the element to the parent scope.">twoWay:bind</a> - <code>checked:bind='complete'</code>.</li>
<li>Completes every todo with <a href="../can-stache-bindings.event.html" title="Respond to events on elements or component ViewModels.">on:event</a> - <code>on:click='completeAll()'</code>.</li>
</ul>
<div class='demo_wrapper' data-demo-src='demos/technology-overview/simple-todos.html'></div>
<h3>Components</h3>
<p>The final core <strong>view</strong> library is <a href="../can-component.html" title="Create a custom element that can be used to manage widgets or application logic.">can-component</a>.</p>
<p><img src="../../docs/can-guides/experiment/technology/observables-dom.png"
alt=""
class='bit-docs-screenshot'/></p>
<p><a href="../can-component.html" title="Create a custom element that can be used to manage widgets or application logic.">can-component</a> is used to create customs elements.  Custom elements are used to
encapsulate widgets or application logic. For example, you
might use <a href="../can-component.html" title="Create a custom element that can be used to manage widgets or application logic.">can-component</a> to create a <code>&lt;percent-slider&gt;</code> element that creates a
slider widget on the page:</p>
<div class='demo_wrapper' data-demo-src='demos/technology-overview/component-slider.html'></div>
<p>Or, you might use <a href="../can-component.html" title="Create a custom element that can be used to manage widgets or application logic.">can-component</a> to make a <code>&lt;task-editor&gt;</code> that uses <code>&lt;percent-slider&gt;</code>
and manages the application logic around editing a todo:</p>
<div class='demo_wrapper' data-demo-src='demos/technology-overview/task-editor.html'></div>
<p>A <a href="../can-component.html" title="Create a custom element that can be used to manage widgets or application logic.">can-component</a> is a combination of:</p>
<ul>
<li>a <a href="../can-define/map/map.html" title="Create observable objects.">DefineMap</a> observable,</li>
<li>a <a href="../can-stache.html" title="Live binding Mustache and Handlebars-compatible templates.">can-stache</a> view, and</li>
<li>a <a href="../can-view-callbacks.html" title="Registered callbacks for behaviors">registered</a> tag name.</li>
</ul>
<p>For example, the following demo defines and uses a <code>&lt;my-counter&gt;</code> custom element. Hit the <button>+1</button> button
to see it count.</p>
<div class='demo_wrapper' data-demo-src='demos/technology-overview/my-counter.html'></div>
<p>The demo defines the <code>&lt;my-counter&gt;</code> element with:</p>
<ul>
<li>The <code>Counter</code> observable constructor as shown in the <a href="#Key_ValueObservables">Key-Value Observables</a> section of this guide:
<pre><code class="language-js">import DefineMap from &quot;can-define/map/map&quot;;
var Counter = DefineMap.extend({
    count: {default: 0},
    increment() {
        this.count++;
    }
});
</code></pre></li>
<li>The <a href="../can-stache.html" title="Live binding Mustache and Handlebars-compatible templates.">can-stache</a> view that incremented the counter as shown in the beginning of this guide:
<pre><code class="language-js">import stache from &quot;can-stache&quot;;
var view = stache(`
  &lt;button on:click='increment()'&gt;+1&lt;/button&gt;
  Count: &lt;span&gt;{{count}}&lt;/span&gt;
`);
</code></pre></li>
<li>A <a href="../can-component.html" title="Create a custom element that can be used to manage widgets or application logic.">can-component</a> that combines the <code>Counter</code> and <code>view</code> as follows:
<pre><code class="language-js">import Component from &quot;can-component&quot;;

Component.extend({
    tag: &quot;my-counter&quot;,
    ViewModel: Counter,
    view: view
});
</code></pre></li>
</ul>
<p>The demo then creates a <code>&lt;my-counter&gt;</code> element like:</p>
<pre><code class="language-html">&lt;my-counter&gt;&lt;/my-counter&gt;
</code></pre>
<p>So <strong>components</strong> are just a combination of a <a href="../can-stache.html" title="Live binding Mustache and Handlebars-compatible templates.">can-stache</a> <strong>view</strong> and a
<a href="../can-define/map/map.html" title="Create observable objects.">DefineMap</a> <strong>observable</strong>.  <a href="../can-component.html" title="Create a custom element that can be used to manage widgets or application logic.">can-component</a> calls the observable a
<a href="../can-component.prototype.ViewModel.html" title="Provides or describes a constructor function that provides values and methods
to the component’s view. The constructor function
is initialized with values specified by the component element’s data bindings.">ViewModel</a>. This is because CanJS's observables are typically
built within a <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel">Model-View-ViewModel (MVVM) architecture</a>.</p>
<p><img src="../../docs/can-guides/experiment/technology/can-component.png"
alt="" class='bit-docs-screenshot'/></p>
<p>Instead of creating the view, view-model as separate entities, they are
often done together as follows:</p>
<pre><code class="language-js">import Component from &quot;can-component&quot;;

Component.extend({
    tag: &quot;my-counter&quot;,
    view: `
        &lt;button on:click='increment()'&gt;+1&lt;/button&gt;
        Count: &lt;span&gt;{{count}}&lt;/span&gt;
    `,
    ViewModel: {
        count: {default: 0},
        increment() {
            this.count++;
        }
    }
});
</code></pre>
<p><a href="../can-component.html" title="Create a custom element that can be used to manage widgets or application logic.">can-component</a> will create a <code>can-stache</code> template from a string <a href="../can-component.prototype.view.html" title="Provides a view to render directly within the component’s element. The view is rendered with the
component’s can-component::ViewModel instance.  &lt;content/&gt; elements within the view are replaced by the source elements within the component’s tag.">view</a> value
and define a <a href="../can-define/map/map.html" title="Create observable objects.">DefineMap</a> type from a plain
object <a href="../can-component.prototype.ViewModel.html" title="Provides or describes a constructor function that provides values and methods
to the component’s view. The constructor function
is initialized with values specified by the component element’s data bindings.">ViewModel</a> value. This is a useful short-hand for creating components. <strong>We will use it for all components going forward.</strong></p>
<h4>Passing data to and from components</h4>
<p>Components are created by inserting their <a href="../can-component.prototype.tag.html" title="Specifies the HTML tag (or node-name) the can-component will be created on.">tag</a> in the DOM or
another <a href="../can-stache.html" title="Live binding Mustache and Handlebars-compatible templates.">can-stache</a> view. For example, <code>&lt;my-counter&gt;&lt;/my-counter&gt;</code> creates an instance of the
<strong>ViewModel</strong> and renders it with the <strong>view</strong> and inserts the resulting HTML inside the <code>&lt;my-counter&gt;</code> tag.</p>
<p><a href="../can-stache-bindings.html" title="Provides template event, one-way bindings, and two-way bindings.">can-stache-bindings</a> can be used to pass values between
component ViewModels and <a href="../can-stache.html" title="Live binding Mustache and Handlebars-compatible templates.">can-stache</a>'s scope.  For example,
we can start the counter's count at 5 with the following:</p>
<pre><code class="language-html">&lt;my-counter count:from='5'&gt;&lt;/my-counter&gt;
</code></pre>
<p>This is shown in the following demo:</p>
<div class='demo_wrapper' data-demo-src='demos/technology-overview/my-counter-5.html'></div>
<p><a href="../can-stache.html" title="Live binding Mustache and Handlebars-compatible templates.">can-stache</a>'s scope is usually made up of other component ViewModels.  <a href="../can-stache-bindings.html" title="Provides template event, one-way bindings, and two-way bindings.">can-stache-bindings</a>
passes values from one ViewModel to another.  For example, the <code>&lt;task-editor&gt;</code> component
connects its <code>progress</code> property to the <code>value</code> property of the <code>&lt;my-slider&gt;</code> with:</p>
<pre><code class="language-html">&lt;percent-slider value:bind='progress'/&gt;
</code></pre>
<div class='demo_wrapper' data-demo-src='demos/technology-overview/task-editor.html'></div>
<p>So on a high-level, CanJS applications are composed of components whose logic is managed
by an observable <em>view-model</em> and whose <em>views</em> create
other components. The following might be the topology of an example application:</p>
<p><img src="../../docs/can-guides/experiment/technology/component-architecture-overview.png"
alt=""
class='bit-docs-screenshot'/></p>
<p>Notice that <code>&lt;my-app&gt;</code>'s <em>view</em> will
render either <code>&lt;page-login&gt;</code>, <code>&lt;page-signup&gt;</code>,
<code>&lt;page-products&gt;</code>, or <code>&lt;page-purchase&gt;</code> based on
the state of it's <em>view-model</em>.  Those page-level components
might use sub-components themselves like <code>&lt;ui-password&gt;</code> or <code>&lt;product-list&gt;</code>.</p>
<h2>Observables and the browser's location</h2>
<p>CanJS's pattern is that you define application logic in one or
more observables, then connect the observables to
various browser APIs.  For example, you can connect the <code>myCounter</code> observable from
the <a href="#Key_ValueObservables">Key-Value Observables</a> section to <code>window.location</code> with:</p>
<pre><code class="language-js">import route from &quot;can-route&quot;;

route.data = myCounter;
route.start();
</code></pre>
<p>This will add <code>#!&amp;count=0</code> to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Location">location</a> hash.</p>
<p>Now, if you called <code>increment()</code> on my counter, the <code>window.location</code> would
change to <code>#!count=1</code>. If you hit the back-button, <code>myCounter.count</code> would be
back to <code>0</code>:</p>
<pre><code class="language-js">myCounter.increment()
window.location.hash  //-&gt; &quot;#!&amp;count=1&quot;

history.back()
myCounter.count       //-&gt; 0
window.location.hash  //-&gt; &quot;#!&amp;count=0&quot;
</code></pre>
<div class='demo_wrapper' data-demo-src='demos/technology-overview/route-counter.html'></div>
<p><a href="../can-route.html" title="Manage browser history and client state by synchronizing the window.location.hash with an observable.">can-route</a> is used to setup a bi-directional relationship with an observable and
the browser's location.</p>
<p><img src="../../docs/can-guides/experiment/technology/observable-routing.png"
alt=""
class='bit-docs-screenshot'/></p>
<p>By default, <code>can-route</code> serializes the observable's data with <a href="../can-param.html" title="Serialize an object or array into a query string.">can-param</a>,
so that the following observable data produces the following url hashes:</p>
<pre><code class="language-js">{foo: &quot;bar&quot;}          //-&gt; &quot;#!&amp;foo=bar&quot;
{foo: [&quot;bar&quot;, &quot;baz&quot;]} //-&gt; &quot;#!&amp;foo[]=bar&amp;foo[]=baz&quot;
{foo: {bar: &quot;baz&quot;}}   //-&gt; &quot;#!&amp;foo[bar]=baz&quot;
{foo: &quot;bar &amp; baz&quot;}    //-&gt; &quot;#!&amp;foo=bar+%26+baz&quot;
</code></pre>
<blockquote>
<p><strong>NOTE 1:</strong> This guide uses hash-based routing instead of pushstate because hash-based routing
is easier to setup. Pushstate routing requires server-support. Use <a href="../can-route-pushstate.html" title="Changes can-route to use pushstate
to change the window's pathname instead
of the hash.
var route = require(&quot;can-route-pushstate&quot;);

route(&quot;{page}&quot;, { page: &quot;home&quot; });
route.start();

route.attr(&quot;page&quot;, &quot;user&quot;);

location.pathname; // -&gt; &quot;/user&quot;">can-route-pushstate</a> for pushstate-based applications. The use of <a href="../can-route-pushstate.html" title="Changes can-route to use pushstate
to change the window's pathname instead
of the hash.
var route = require(&quot;can-route-pushstate&quot;);

route(&quot;{page}&quot;, { page: &quot;home&quot; });
route.start();

route.attr(&quot;page&quot;, &quot;user&quot;);

location.pathname; // -&gt; &quot;/user&quot;">can-route-pushstate</a> is almost identical to <a href="../can-route.html" title="Manage browser history and client state by synchronizing the window.location.hash with an observable.">can-route</a>.</p>
</blockquote>
<blockquote>
<p><strong>NOTE 2:</strong> <a href="../can-route.html" title="Manage browser history and client state by synchronizing the window.location.hash with an observable.">can-route</a> uses hash-bangs (<code>#!</code>) to comply with a now-deprecated
<a href="https://developers.google.com/webmasters/ajax-crawling/docs/getting-started">Google SEO</a>
recommendation.</p>
</blockquote>
<p>You can register routes that controls the relationship between the
observable and the browser's location. The following registers
a translation between URLs and route properties:</p>
<pre><code class="language-js">route.register(&quot;{count}&quot;)
</code></pre>
<p>This results in the following translation between observable data and url hashes:</p>
<pre><code class="language-js">{count: 0}                  //-&gt; &quot;#!0&quot;
{count: 1}                  //-&gt; &quot;#!1&quot;
{count: 1, type: &quot;counter&quot;} //-&gt; &quot;#!1&amp;type=counter&quot;
</code></pre>
<p>You can add data when the url is matched.  The following registers
data for when the URL is matched:</p>
<pre><code class="language-js">route.register(&quot;products&quot;, {page: &quot;products&quot;});
route.register(&quot;products/{id}&quot;, {page: &quot;products&quot;})
</code></pre>
<p>This results in the following translation between observable data and url hashes:</p>
<pre><code class="language-js">{page: &quot;products&quot;}          //-&gt; &quot;#!products&quot;
{page: &quot;products&quot;, id: 4}   //-&gt; &quot;#!products/4&quot;
</code></pre>
<p>Registering the empty route (<code>&quot;&quot;</code>) provides initial state for the
application. The following makes sure the count starts at 0 when the hash is empty:</p>
<pre><code class="language-js">route.register(&quot;&quot;,{count: 0});
</code></pre>
<div class='demo_wrapper' data-demo-src='demos/technology-overview/route-counter-registered.html'></div>
<h3>Routing and the root component</h3>
<p>Understanding how to use <a href="../can-route.html" title="Manage browser history and client state by synchronizing the window.location.hash with an observable.">can-route</a> within an application comprised of <a href="../can-component.html" title="Create a custom element that can be used to manage widgets or application logic.">can-component</a>s
and their <a href="../can-stache.html" title="Live binding Mustache and Handlebars-compatible templates.">can-stache</a> views and observable view-models can be tricky.</p>
<p>We'll use the following example to help make sense of it:</p>
<div class='demo_wrapper' data-demo-src='demos/technology-overview/route-mini-app.html'></div>
<p>This example shows the <code>&lt;page-login&gt;</code> component until someone has logged in.  Once they have
done that, it shows a particular component based upon the hash. If the hash is empty (<code>&quot;&quot;</code> or <code>&quot;#!&quot;</code>),
the <code>&lt;page-home&gt;</code> component is shown.  If the hash is like <code>tasks/{taskId}</code> it will show the <code>&lt;task-editor&gt;</code> component we created previously. (<em>NOTE: We will show how to persist changes
to todos in a upcoming service layer section.</em>)</p>
<p>The switching between different components is managed by a <code>&lt;my-app&gt;</code> component. The topology of
the application looks like:</p>
<p><img src="../../docs/can-guides/experiment/technology/routing-app-overview.png"
alt="The my-app component on top. The page-home, page-login, task-editor nodes are children of my-app. percent-slider component is a child of task-editor."
class='bit-docs-screenshot'/></p>
<p>In most applications, <a href="../can-route.html" title="Manage browser history and client state by synchronizing the window.location.hash with an observable.">can-route</a> is connected to the top-level component's
<a href="../can-component.prototype.ViewModel.html" title="Provides or describes a constructor function that provides values and methods
to the component’s view. The constructor function
is initialized with values specified by the component element’s data bindings.">ViewModel</a>. We are going to go through the process of
building <code>&lt;my-app&gt;</code> and connecting it
to <a href="../can-route.html" title="Manage browser history and client state by synchronizing the window.location.hash with an observable.">can-route</a>. This is usually done in four steps:</p>
<ol>
<li>Connect the top-level component's view-model to the routing <a href="../can-route.data.html" title="This is the internal observable object underlying can-route. It can be set in order to cross-bind a top level state object (Application ViewModel) to can-route.">data</a>.</li>
<li>Have the top-level component's <a href="../can-component.prototype.view.html" title="Provides a view to render directly within the component’s element. The view is rendered with the
component’s can-component::ViewModel instance.  &lt;content/&gt; elements within the view are replaced by the source elements within the component’s tag.">view</a> display the right sub-components based on the view-model state.</li>
<li>Define the top-level component's view-model (sometimes called <em>application view-model</em>).</li>
<li>Register routes that translate between the URL and the application view-model.</li>
</ol>
<h3>Connect a component's view-model to can-route</h3>
<p>To connect a component's view-model to can-route, we first need to create a basic
component. The following creates a <code>&lt;my-app&gt;</code> component that displays its <code>page</code> property and
includes links that will change the page property:</p>
<pre><code class="language-js">import Component from &quot;can-component&quot;;
import stache from &quot;can-stache&quot;;
import DefineMap from &quot;can-define/map/map&quot;;
import route from &quot;can-route&quot;;
import &quot;can-stache-route-helpers&quot;;

Component.extend({
    tag: &quot;my-app&quot;,
    view: stache(`
        The current page is {{page}}.
        &lt;a href=&quot;{{ routeURL(page='home') }}&quot;&gt;Home&lt;/a&gt;
        &lt;a href=&quot;{{ routeURL(page='tasks') }}&quot;&gt;Tasks&lt;/a&gt;
    `),
    ViewModel: {
        page: &quot;string&quot;
    }
})
</code></pre>
<blockquote>
<p><strong>NOTE:</strong> Your html needs a <code>&lt;my-app&gt;&lt;/my-app&gt;</code> element to be able to see the
component's content.  It should say &quot;The current page is .&quot;.</p>
</blockquote>
<p>To connect the component's VM to the url, we:</p>
<ul>
<li>set <a href="../can-route.data.html" title="This is the internal observable object underlying can-route. It can be set in order to cross-bind a top level state object (Application ViewModel) to can-route.">data</a> to the custom element.</li>
<li>call and <a href="../can-route.start.html" title="Initializes can-route.">start</a> to begin sending url values to the component.</li>
</ul>
<pre><code class="language-js">route.data = document.querySelector(&quot;my-app&quot;);
route.start();
</code></pre>
<p>At this point, changes in the URL will cause changes in the <code>page</code>
property. See this by clicking the links and the back/refresh buttons below:</p>
<div class='demo_wrapper' data-demo-src='demos/technology-overview/route-mini-app-start.html'></div>
<h3>Display the right sub-components</h3>
<p>When building components, we suggest designing the <a href="../can-component.prototype.view.html" title="Provides a view to render directly within the component’s element. The view is rendered with the
component’s can-component::ViewModel instance.  &lt;content/&gt; elements within the view are replaced by the source elements within the component’s tag.">view</a>
before the <a href="../can-component.prototype.ViewModel.html" title="Provides or describes a constructor function that provides values and methods
to the component’s view. The constructor function
is initialized with values specified by the component element’s data bindings.">ViewModel</a>.  This helps you figure out what logic
the <a href="../can-component.prototype.ViewModel.html" title="Provides or describes a constructor function that provides values and methods
to the component’s view. The constructor function
is initialized with values specified by the component element’s data bindings.">ViewModel</a> needs to provide an easily understood
<a href="../can-component.prototype.view.html" title="Provides a view to render directly within the component’s element. The view is rendered with the
component’s can-component::ViewModel instance.  &lt;content/&gt; elements within the view are replaced by the source elements within the component’s tag.">view</a>.</p>
<p>We'll use <a href="../can-stache.helpers.switch.html" title="">{{#switch(expression)}}</a> to switch between different components
based on a <code>componentToShow</code> property on the view-model. The result looks like the following:</p>
<pre><code class="language-js">Component.extend({
    tag: &quot;my-app&quot;,
    view: stache(`
        {{#switch(componentToShow)}}
            {{#case(&quot;home&quot;)}}
                &lt;page-home isLoggedIn:from=&quot;isLoggedIn&quot; logout:from=&quot;logout&quot;/&gt;
            {{/case}}
            {{#case(&quot;tasks&quot;)}}
                &lt;task-editor id:from=&quot;taskId&quot; logout:from=&quot;logout&quot;/&gt;
            {{/case}}
            {{#case(&quot;login&quot;)}}
                &lt;page-login isLoggedIn:bind=&quot;isLoggedIn&quot; /&gt;
            {{/case}}
            {{#default}}
                &lt;h2&gt;Page Missing&lt;/h2&gt;
            {{/default}}
        {{/switch}}
    `),
    ...
})
</code></pre>
<p>Notice that the view-model will need the following properties:</p>
<ul>
<li><strong>isLoggedIn</strong> - If the user is logged in.</li>
<li><strong>logout</strong> - A function that when called logs the user out.</li>
<li><strong>taskId</strong> - A taskId in the hash.</li>
</ul>
<p>We will implement these properties and <code>componentToShow</code> in the
<a href="../can-component.prototype.ViewModel.html" title="Provides or describes a constructor function that provides values and methods
to the component’s view. The constructor function
is initialized with values specified by the component element’s data bindings.">ViewModel</a>.</p>
<h3>Define the view-model</h3>
<p>Now that we've designed the <em>view</em> it's time to code the observable view-model
with the logic to make the view behave correctly. We implement the
<code>ViewModel</code> as follows:</p>
<pre><code class="language-js">Component.extend({
    tag: &quot;my-app&quot;,
    ...
    ViewModel: {
        // Properties that come from the url
        page: &quot;string&quot;,
        taskId: &quot;string&quot;,

        // A property if the user has logged in.
        // `serialize: false` keeps `isLoggedIn` from
        // affecting the `url` and vice-versa.
        isLoggedIn: {
            default: false,
            type: &quot;boolean&quot;,
            serialize: false
        },

        // We show the login page if someone
        // isn't logged in, otherwise, we
        // show what the url points to.
        get componentToShow(){
            if(!this.isLoggedIn) {
                return &quot;login&quot;;
            }
            return this.page;
        },

        // A function we pass to sub-components
        // so they can log out.
        logout() {
            this.isLoggedIn = false;
        }
    }
});
</code></pre>
<blockquote>
<p>NOTE: The <a href="../can-define.types.serialize.html" title="Defines custom serialization behavior for a property.">serialize</a> property behavior controls the
<a href="../can-define/map/map.prototype.serialize.html" title="Get a serialized representation of the map instance and its children.">serializable</a> properties of
a <a href="../can-define/map/map.html" title="Create observable objects.">DefineMap</a>. Only
serializable properties of the map are used by <a href="../can-route.html" title="Manage browser history and client state by synchronizing the window.location.hash with an observable.">can-route</a> to
update the url. <code>serialize: false</code> keeps <code>isLoggedIn</code> from
affecting the <code>url</code> and vice-versa. Getters like <code>componentToShow</code>
are automatically configured with <code>serialize: false</code>.</p>
</blockquote>
<p>Finally, our component works, but the urls aren't easy to
remember (ex: <code>#!&amp;page=home</code>). We will clean that up in the
next section.</p>
<h3>Register routes</h3>
<p>Currently, after the user logs in, the application will show <code>&lt;h2&gt;Page Missing&lt;/h2&gt;</code> because if the url hash is empty, <code>page</code> property will be undefined. To have <code>page</code>
be <code>&quot;home&quot;</code>, one would have to navigate to <code>&quot;#!&amp;page=home&quot;</code> ... yuck!</p>
<p>We want the <code>page</code> property to be <code>&quot;home&quot;</code> when the hash is empty.  Furthermore,
we want urls like <code>#!tasks</code> to set the <code>page</code> property.  We can do that
by registering the following route:</p>
<pre><code class="language-js">route.register(&quot;{page}&quot;, {page: &quot;home&quot;});
</code></pre>
<p>Finally, we want <code>#!tasks/5</code> to set <code>page</code> to <code>&quot;tasks&quot;</code> and <code>taskId</code>
to <code>&quot;5&quot;</code>.  Registering the following route does that:</p>
<pre><code class="language-js">route.register(&quot;tasks/{taskId}&quot;, {page: &quot;tasks&quot;});
</code></pre>
<p>Now the mini application is able to translate changes in the url to
properties on the component's view-model.  When the component's view-model
changes, the view updates the page.</p>

</section>

  


<script type="text/javascript">
  window.docObject = {"src":{"path":"docs/can-guides/experiment/technology/technology.md"},"description":"Learn the basics of the core parts of CanJS's technology. \n","name":"guides/technology-overview","title":"Technology Overview","type":"page","parent":"guides/getting-started","order":1,"outline":"2","comment":" ","pathToRoot":"../.."};
</script>
</article>
      
        <footer><p>CanJS is part of <a href="https://donejs.com" target="_blank">DoneJS</a>. Created and maintained by the core <a href="https://donejs.com/About.html#team" target="_blank">DoneJS team</a> and <a href="https://www.bitovi.com" target="_blank">Bitovi</a>. <strong>Currently 4.0.1.</strong></p>
</footer>
      
    </div>
  </div>
</div>
<survey-ad>
  <button aria-label="Close" class="close" type="button">
    <span aria-hidden="true">&times;</span>
  </button>
  <a href="https://donejs.com/survey.html" target="_blank">
    Help us improve CanJS by taking our community survey
  </a>
</survey-ad>


		
			<script>
				steal = {
				  	instantiated: {
				    	"bundles/bit-docs-site/static.css!$css" : null
				  	}
			  	};
			</script>
			<script type='text/javascript' data-main="bit-docs-site/static" src="../static/steal.production.js"></script>
		
		<script async defer src="https://buttons.github.io/buttons.js"></script>

		<!-- root-level elements with attributes necessary for the app -->
		<div path-prefix=".."></div>

	</body>
</html>
